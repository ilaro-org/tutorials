# Openscad Tutorial

## Intro

Openscad es una especie de compilador de geometría 3d basado en el paradigma CSG.
Es un entorno y un lenguaje de programación,con un rango de entradas y salidas muy específicos para la generación de modelos tridimensionales. Como tal consta de una sintaxis que es imprescindible respetar para la correcta ejecución de los programa. Dado que se describe el objeto de forma paramétrica y mediante sólidos normalmente genera una topología "watertight", imprescindible a la hora de modelar objetos imprimibles. Es ampliamente usado por los usuarios de la comunidad reprap por su facilidad a la hora de compartir y personalizar los diseños.

## Intro

Familiarizarse con la sintaxis básica de openscad.
Aprender cómo se estructuran los archivos de openscad.
Aprender cómo se relacionan los módulos externos en openscad.
Familiarizarse con los principales módulos de openscad.
Poder modificar un diseño de openscad parametrizado con tal de adaparlo a nuestras necesidades.

## IDE

Interfaz
La interfaz presenta cuatro espacios principales:


• superior: menús
• izquierda: código
• derecha superior: visualización tridimensional. Resultado geométrico
• derecha inferior: consola. Resultado textual: propiedades, errores, etc.

## Navegación

Botones del ratón:

• izquierdo: rotación horizontal
• izquiedo+shift: rotación vertical
• arrastrar (derecho/izquierdo): paning
• zoom: rueda
	arrastrar + shift
	
Teclas:
• zoom: botones + -

Modos de visualización de la geometría resultado (renderizado)
F5: Compilar genera una previsualización
F6: Compilar + renderizar

Los dos motores de renderización disponibles son:
F9: OpenCSG: resultados casi instantaneos, pero poco eficiente en modelos altamente no­convexos.
F10/F11: CGAL (Surfaces/Grid): más lento en la primera compilación, pero con mejor frame­rate posteriormente.

Opciones de visualización
`Ctrl +1`: mostrar aristas
`Ctrl +2`: mostrar ejes
`Ctrl +3`: mostrar el origen de coordenadas
`Ctrl+4, Ctrl+5, ..., Ctrl+0, Ctrl+P`: Alienar la vista a los diferentes planos.

Exportar un modelo a formato stl

Seleccionar "Export as STL..." del menú "Design". Nombrar el archivo a crear incluyendo la extesión “.stl”.


## LENGUAJE

El código en openscad se optimiza principalmente mediante el uso de módulos, que permiten reutilización y compactación del código.
El cuerpo de éstos y otras estructuras como los bucles vienen definidos por los símbolos “{“ y “}”.

El código se va anidando de este módo en estructuras arboreas, que determinan los diferentes scopes.

## DEBUGING

`//`: para comentar una linea

`/*`: para comentar varias lineas

`*/`

`echo(“hello world”)`: imprime en consola en valor o cadena de carácteres

`color([(1,0,0)])`: colorea la gemetria creada bajo esta instrucción

`%`Este sub­árbol se computa aparte y se grafica en gris transparente.

`#`Este sub­árbol se coloreará en rosa transparente.

`*`Ignorar este sub­árbol a la hora de generar el modelo.

#VARIABLES

Se crean mediante un nom• bre seguido de un operador de asignación.
Su valor se define en la compilación, no durante la ejecución, de modo que en un scope dado todas las instancias de una variable toman el última valor asignado.

```
myvar = 1;

for (i=[10:50])
{
	assign (angle = i*360/20, distance = i*10, r = i*2)
	{
		rotate(angle, [1, 0, 0])
		translate([0, distance, 0])
		sphere(r = r);
	}
}

```

#OPERADORES

`+` suma

­`-` diferenci

`*` multiplicación

`/` división

`%` módulo

`<` menor

`<=` igual o menor

`==` igual

`!=` diferente

`>=` mayor o igual

`>` mayor

`&&` Y lógica

`||` O lógica

`!` negación lógica

`?` operador tri­paramétrico condicional

vector­número: *, /
vector­vector: +, ­, * (producto vectorial)
matriz­vector: *

#FUNCIONES

**FUNCIONES ARITMÉTICAS**
abs, ceil, floor, exp, ln, len, max, min, log, pow, rands, round, sign, sqrt

**FUNCIONES TRIGONOMÉTRICAS**
acos, asin, atan, cos, sin, tan

**FUNCIONES DE USUARIO**
my_d=20;
function r_from_dia(my_d) = my_d / 2;
echo("Diameter ", my_d, " is radius ", r_from_dia(my_d));

**FUNCIONES PRIMITIVAS**
Las funciones para la generación de primitivas geometricas permiten overloading/sobrecarga, de modo que el número de parametros a pasar es variable. Los parámetros que no se pasan, toman por valor el asignado por defecto.

Los parametros se pueden nombrar al pasar el valor, o dejarlos implicitos:

circle(r = 10);
circle(10); // equivale al anterior

Las siguientes variables especiales controlan la resolución de geometría curva generada en 1 o 2

direcciones:

$fa : ángulo mínimo de un segmento de arco. (por defecto 12)
$fs : longitud mínima de un segmento de arco. (por defecto 2)
$fn : representa el número de segmentos de un arco e invalida las anteriores variables cuando se utiliza.

**2D** en las que se utiliza una altura representativa de 1

```
square 		: size, center

square (); // uses default side, size=[1,1]

square ([2,2],center =true);

circle 		: r

circle(r = 10);

polygon : points, paths, convexity

polygon(points=[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]], paths=[[0,1,2],

[3,4,5]]);

import_dxf :
```

**3D**

```
cube		: size, center

cube(size = 1, center = false);

cube([1,2,3],true);


sphere 		: r

sphere(2, $fa=5, $fs=0.1);

sphere(2, $fn=100);


cylinder	 : h, r1, r2, r, center

cylinder(h = 10, r1 = 10, r2 = 20, center = false);

cylinder(h = 10, r=20);

cylinder(h = 10, r=20, $fs=6);


polyhedron	 : points, triangles, convexity
Hay que tener consistencia en la dirección al enumerar los puntos!

polyhedron(points = [ [x, y, z], ... ], triangles = [ [p1, p2, p3..], ... ],

convexity = N);
```

#BLOQUES

asignación
asign(...) : asigna valores en un determinado scope.

bucle for : repite una acción con un/os parametros que varian de forma incrmental

```
Version vector: for (variable=<vector>) <do_something> <variable>

for(z=[­1, 1]) // two iterations, z = ­1, z = 1


{
	translate([0, 0, z])
	cube(size = 1, center = false);
	}

Versión rango: for (variable=<range>) <do_something>

for(i=[0:5])

{
	rotate(i*360/6, [1, 0, 0])
	translate([0, 10, 0])
	sphere(r = 1);
}
```
el bucle intersection_for() es necesario cuando se quiere utilizar for() junto a intersection().

**MÓDULOS DE USUARIO**
Los módulos además de ser definidos y usados en el archivo principal del modelo, también se pueden obtener de otros archivos enlazados. Esto se puede realizar de dos formas, mediante:
include `<filename>`: equivalente a incluir el código fuente referenciado en nuestro archivo
use `<filename>`: importa las definiciones de módulos y funciones pero sin ejecutar ninguna llamada a estos.

**DEFINICIÓN:**
```
module NOMBRE (<parametros>) {
	// cuerpo
}
```

**LLAMADA:**
```
**NOMBRE(<parametros>);**
```
bloques de transformación
Actuan sobre una función (pudiendo omitir los símbolos de bloque) o varias, y de forma anidada.

• Transformaciones lineales
`translate()`	 : distancia en cada eje
`scale()`		 : magnitud en cada eje
`rotate()`	 : águlo y eje / ángulos en los tres `ajes cartesianos`
`mirror()`         : normal al plano de simetría

• Transformaciones booleaneas
`union()`
`difference()`
`intersection()`

• Transformaciones geometricas
`linear_extrude()` 	: altua, centro, convexidad
`rotate_extrude()` 	: convexidad
`projection()`
`twist()`
`minkowski()` 		: suma vectorial de dos objetos tridimensionales
`hull()` 			: (sólo 2d!)






